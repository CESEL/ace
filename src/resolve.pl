#!/usr/bin/perl -w

use warnings;
#use strict;

use DBI;
use Cwd;
use Regexp::Common; 

use IO::File;

use File::Find::Rule;
use File::Slurp;

use Config::General;

use Text::Ngrams;
use Text::Document;
use File::Basename;
use String::CamelCase qw(camelize decamelize wordsplit);
use String::Trim;
use Lingua::StopWords qw(getStopWords);
use Path::Class;

#if we leave the html in it could get confused with a generic
#random flags to start and end code snippets (KLUDGE: will mess up position!): could remove it before processing
#need a space before and after because otherwise some regexp look backwards on char
my $START_CODE = ' prxh_START_SNIPPET ';
my $END_CODE = ' prxh_END_SNIPPET ';

my $config_path = shift @ARGV;

#two passes, find trustued code elements, then reparse to pull out all ces
my $pass;
if (@ARGV > 0) {
    $pass = shift @ARGV;
}

if (!defined $pass) {
    $pass = 'first';
}

if (!defined $config_path) {
	$config_path = 'config';
}
die "Config file \'$config_path\' does not exist"
	unless (-e $config_path);

my %config =  Config::General::ParseConfig($config_path);

my $dbh_ref = DBI->connect("dbi:Pg:database=$config{db_name}", '', '', {AutoCommit => 0});

#get positions for du
my %ce_pos;
my $get_pos = $dbh_ref->prepare(q{select pos, simple from clt where du = ?});

#get all the valid CEs for the second pass
my %ce;
if ($pass eq 'second') {

    #define dictionary acceptable CEs
    my $get_hash = $dbh_ref->prepare(q{select pqn, simple from ce where kind <> 'package' and kind <> 'variable'});
    $get_hash->execute or die $dbh_ref->errstr;
    while ( my($pqn, $simple) = $get_hash->fetchrow_array) {
            $ce{$simple} = 1; #$pqn; --can have dups so resolve as undefined
    }
    $get_hash->finish;
}

#see create.sql for table definition
my $insert_simple = $dbh_ref->prepare(q{insert into clt(snip, tid, du, pqn, simple, kind, trust, pos) values(?,?,?,?,?,?,?,?)});

#the symbols we're allowing
my $ln = '-a-z_0-9';
my $l = 'a-z_';
my $u = 'A-Z_';
my $w = '-A-Za-z_0-9';
my $a = $w.'.';
my $an = $w.'@'; #annotations

#change what is a word boundry - from http://www.perlmonks.org/?node_id=308744
my $b = "(?:(?<![$a])(?=[$a])|(?<=[$a])(?![$a]))"; #dot is not considered a boundary
my $n = "(?:(?<![$an])(?=[$an])|(?<=[$an])(?![$an]))"; #dot is, but @ is not considered a boundary
my $d = "(?:(?<![$w])(?=[$w])|(?<=[$w])(?![$w]))"; #dot is considered a boundary
my $s = "(?:(?<![ ])(?=[ ])|(?<=[ ])(?![ ]))"; #space is the only boundary

#REMEMBER: inside " you need to \\ on any special char eg \\s+
#http://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html
my $primative = 'byte|short|int|long|float|double|boolean|char';

#http://en.wikipedia.org/wiki/Java_annotation
my $annotation = '@Override|@Deprecated|@SuppressWarnings|@Retention|@Documented|@Target|@Inherited';

#code like terms
my $class1 = "[$u][$w\$]*"; #may have a $ in autogenerated classes
my $class = "$class1(?:[.]$class1){0,1}"; #Nested class: eg Map.Entry
my $pack = "[$l][$ln]*"; #package
my $generic = "$class(?:<(?:$class|$primative) (?:\\s*, \\s* (?:$class|$primative))*>){0,1}"; #KLUDGE, don't deal with extends etc
my $meth = "[$l][$w\$]*"; 
my $var = "[$l][$w\$]*";
my $const = "[$u][-0-9$u\$]*";
#my $cast = "\((?:$class|$generic)\)\s+"; #KLUDGE cast before constructor 

#my $literals = '(\d|true|false)'; #chars, strings, hex #KLUDGE??

#http://java.about.com/od/javasyntax/a/reservedwords.htm
#only that can be followed by ( 
my $reserved = 'for|while|if'; 

#stupid stuff like certificates will look like classes so limit the length of a class
my $MAX_CLASS_LEN = 50;

my %var_to_class = (); #hash map of variable definitions to type
my $order = 0; #the order in which ces are found

#pre-condition: already checked that it is a meth
sub meth_two_camel($) {

    my($name) = @_;

    #is there atleast one uppercase?
    if ($name =~ /[A-Z]/) {
        return 1;
    }

    #underscores and dashes
    if ((my $len = $name) =~ s/[^-_]//g) {
        if (length($len) >= 1) {
            return 1;
        }
    }

    return 0;
}

#already checked that it could be a class
sub class_two_camel($) {

    my($name) = @_;

    #upper, followed by a lower, followed by an upper
    if ($name =~ /^[A-Z]+ .*? [a-z] .*? [A-Z]/xms){
        return 1;
    }

    #underscores and dashes
    if ((my $len = $name) =~ s/[^-_]//g) {
        if (length($len) >= 1) {
            return 1;
        }
    }

    return 0;
}


#Parse the paramters only
#e.g., methodName(String s, SomeClass sc)
sub meth_vars($$$$$) {

    my($is_snippet, $tid, $du, $pa, $pap) = @_;

    pos($pa) ++; #move over '('

    while ($pa =~ /\G\s* (?:final\s+){0,1} ($generic|$class|$primative)\s+ ($var) \s*[,]{0,1}/gcxms) {
        #KLUDGE, scope number?)

        print " class = $1\n variable = $2\n\n";
        $var_to_class{$2} = $1;

        #pap already includes pre
        #class 
        $insert_simple->execute($is_snippet, $tid, $du, $1, $1, 'type', 0, $pap+$-[1]);
        #variable
        $insert_simple->execute($is_snippet, $tid, $du, $1, $2, 'variable', 0, $pap+$-[2]);
    }

}

sub parse($$$$$$$) {

    my($tid, $du, $content, $d_class, $inside_quote, $is_snippet, $pre) = @_;

    #the order of the regexp is important, be as specific as possible and 
    # put more general ones later on
    CONTENT:
    while (not $content =~ m/\G\z/gc) {


        #extend is about processing Class.method().method().FIELD for example
        my $extend = undef;


        #print substr($content, pos($content), 15), "\n"; 

        #are we inside a code snippet?
        #must contain at least one ; otherwise it might just be a code element set out from free-from
        if ($content =~ m|\G $START_CODE|gcxms) { 

            my $tmp_pos = pos($content);

            if ($content =~ m|\G (.*? ; .*?) $END_CODE|gcxms) {
                $is_snippet = 1;
            }

            pos($content) = $tmp_pos; 

        }
        elsif ($content =~ m|\G $END_CODE|gcxms) {
            $is_snippet = 0;
        }

        #don't want to get tricked by if( for example
        if ($content =~ /\G${b} ($reserved) \s* [(] /gcxms) {

            #enhanced for loop 14.14.2
            if($1 eq 'for' and 
                # e.g., for (String cn : cns) 
                $content =~ /($class|$primative|$generic) \s+ ($var) \s* [:]/gcxms) {

                my($cl,$va) = ($1, $2);
                my($clp, $vap) = ($pre+$-[1],$pre+$-[2]);

                print " class = $cl\n variable = $va\n\n";
                $var_to_class{$va} = $cl;

                #class
                $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 0, $clp);
                #variable
                $insert_simple->execute($is_snippet, $tid, $du, $cl, $va, 'variable', 0, $vap);

            }
        }

        #Are we inside quotes? Effects certain statments, search for $inside_quote)
        elsif (!defined $inside_quote and $content =~ /\G (\".*?\")/gcxms) {
            parse($tid, $du, $1, $d_class, 
                1, #set inside quote = 1 = true
                $is_snippet, $pre+$-[1]);
        }

        #discard System methods
        elsif ($content =~ /\G${b} (System([.] $meth)+) ($RE{balanced}{-parens=>'()'})*/gcxms) {
            print "$1 \n";

            if (defined $3) {
                print " param = $3\n";
                parse($tid, $du, $3, $d_class, $inside_quote, $is_snippet, $pre+$-[3]);
            }

            print "\n";
        }

        #annotations
        #KLUDGE: will pickup @Peter blah... -> hopefull will introduce few FP, 
        #   annotation can be complex, basically another language
        elsif ($content =~ /\G ${n} (\@$class) \s* ($RE{balanced}{-parens=>'()'})* ${b}/gcxms) {

            my $an = $1;
            my $anp = $pre+$-[1];

            #Not interested in the default annotations
            if ($an =~ /(^$annotation$)/) {
                print " Discard default annotation: $1 \n\n";
            }
            else {
                print " annotation = $an\n";
                $insert_simple->execute($is_snippet, $tid, $du, $an, $an, 'annotation', 10, $anp);
            }

            #will process, but will only get fully qualified
            if (defined $2) {
                print " annotation param = $2\n";
                parse($tid, $du, $2, $d_class, $inside_quote, $is_snippet, $pre+$-[2]);
            }
        }

        #KLUDGE: the following regexps for declarations don't consider that var
        #may be in different scope, but don't care because doc units are small
        #(e.g., post, section). Also going to do recodoc style context matching on 
        #doc unit, so would override anyways 
        #Note: will overwrite old val, so atleast it's closest for var

        #assignment: full type and constructor
        #e.g. "SomeClass somevar = new SomeOtherClass()"
        #Variable is compile time type (e.g., SomeClass not SomeOtherClass) 
        elsif ($content =~ /\G${b} ($primative|$class|$generic) \s+ # the type
                            ($var|$const) \s* = \s* #the variable
                            new \s+ (?:\([$u][$w]*\)\s*){0,1} #possible cast ignored
                            ($class|$generic) #the constructor
                            ($RE{balanced}{-parens=>'()'})* [ .;]/gcxms)   {

            #KLUDGE: will ignore any chaining on the constructor
            #KLUDGE: skipped if it is a primative instead of a constructor

            my($cl,$va,$co) = ($1, $2, $3);
            my($clp, $vap, $cop) = ($pre+$-[1],$pre+$-[2],$pre+$-[3]);

            #class
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 0, $clp);
            #variable
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $va, 'variable', 0, $vap);
            #constructor
            $insert_simple->execute($is_snippet, $tid, $du, $co, $co, 'constructor', 0, $cop);

            my $pa = '';
            if(defined $4) {
                $pa = $4;
                parse($tid, $du, $4, $d_class, $inside_quote, $is_snippet, $pre+$-[4]);
            }


            print " class = $cl\n variable = $va\n Constructor = $co\n param = $pa\n\n";
            $var_to_class{$va} = $cl;

            #new class
            if($content =~ /\G\s* ($RE{balanced}{-parens=>'{}'})/gcxms) {
                $var_to_class{'this'} = $cl;
                parse($tid, $du, $1, $co, $inside_quote, $is_snippet, $pre+$-[1]);
            }



        }
        #assignment: just constructor: same KLUDGES as above apply
        #e.g. "somevar = new SomeClass()"
        #Variable is runtime type 
        elsif ($content =~ /\G${b} ($var|$const) \s+ = \s+ #the variable
                            new \s+ (?:\([$u][$w]*\)\s*){0,1} #possible cast ignored
                            ($class|$generic|$primative) #the constructor
                            ($RE{balanced}{-parens=>'()'})* [ .;]/gcxms)   {

            my($va,$co) = ($1, $2);
            my($vap, $cop) = ($pre+$-[1],$pre+$-[2]);

            my $pa = '';
            if(defined $3) {
                $pa = $3;
                parse($tid, $du, $pa, $d_class, $inside_quote, $is_snippet, $pre+$-[3]);
            }

            print " variable = $va\n constructor = $co\n param = $pa\n\n";
            $var_to_class{$va} = $co;

            $insert_simple->execute($is_snippet, $tid, $du, $co, $co, 'constructor', 0, $cop);
            $insert_simple->execute($is_snippet, $tid, $du, $co, $va, 'variable', 0, $vap);

            #new class
            if($content =~ /\G\s* ($RE{balanced}{-parens=>'{}'})/gcxms) {

                $var_to_class{'this'} = $co;
                parse($tid, $du, $1, $co, $inside_quote, $is_snippet, $pre+$-[1]);
            }
           
        }
        #assignment: multiple variables
        #e.g., Person firstPerson, secondPerson, thirdPerson;
        elsif ($content =~ /\G${b} ($primative|$class|$generic) \s+ 
                            ((?:(?:$var|$const) \s* , \s*)+ (?:$var|$const)) \s* [;]/gcxms) {

            my($cl,$va) = ($1, $2);
            my($clp, $vap) = ($pre+$-[1],$pre+$-[2]);

            #class
            print " class = $cl\n";
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 0, $clp);

            while ($va =~ /\G ($var|$const)\s* ,* \s*/gcxms) { 
   
                #variable
                print "  variable = $1\n";
                $insert_simple->execute($is_snippet, $tid, $du, $cl, $1, 'variable', 0, $vap+$-[1]);

            }

            print "\n";

        }
        #assignemnt: constructor on it's own 
        #e.g., new SomeClass()
        #KLUDGE: generic might not end in ()
        #KLUDGE: inner class extends?
        elsif ($content =~ /\G${b} new \s+ (?:\([$u][$w]*\)\s*){0,1} #possible cast ignored
                            ($class|$generic) #the constructor
                            ($RE{balanced}{-parens=>'()'})\s*/gcxms)   {

            my($co, $pa) = ($1, $2);
            my($cop,$pap) = ($pre+$-[1],$pre+$-[2]);

            print " constructor = $co\n param = $pa\n\n";
            $insert_simple->execute($is_snippet, $tid, $du, $co, $co, 'constructor', 0, $cop);

            parse($tid, $du, $pa, $d_class, $inside_quote, $is_snippet, $pap);

            #new class
            if($content =~ /\G ($RE{balanced}{-parens=>'{}'})/gcxms) {
                $var_to_class{'this'} = $co;
                parse($tid, $du, $1, $co, $inside_quote, $is_snippet, $pre+$-[1]);
            }


        }
        #assignment: don't care what's on righthand side 
        #e.g., String string = "hello world";
        #using $inside_quote to to avoid println("Got it = " + var ...
        elsif (!defined $inside_quote and 
                $content =~ /\G${b} ($primative|$class|$generic) \s+ ($var|$const) \s* [=;]/gcxms) {

            my($cl,$va) = ($1, $2);
            my($clp, $vap) = ($pre+$-[1],$pre+$-[2]);

            print " class = $cl\n variable = $va\n\n";
            $var_to_class{$va} = $cl;

            #class
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 0, $clp);
            #variable
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $va, 'variable', 0, $vap);
        }

        #Dealing with stacktraces 
        #eg  java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:65)
        #Exceptions can be dealt with by *Exception* in class
        elsif ($content =~ /\G${b} (($pack [.])+$pack) [.] ($class) [.] ($meth) \($class\.java:\d+\)/gcxms) {
            my($pac,$cl,$me) = ($1,$3,$4);
            my($pacp, $clp, $mep) = ($pre+$-[1],$pre+$-[3],$pre+$-[4]);
            print " stacktrace: package = $pac\n class = $cl\n meth = $me\n\n";

            #the package and class
            $insert_simple->execute($is_snippet, $tid, $du, $pac, $cl, 'package', 8, $pacp);
            #the class on its own
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 8, $clp);
            #the method
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $me, 'method', 8, $mep);

        }

        #Partially qualified: variable.method()
        elsif ($content =~ /\G ${b} (?:(?:this|super) \s* \. \s*)*?  ($var|$const) \s* [.] \s* ($meth) \s* ($RE{balanced}{-parens=>'()'})/gcxms) {

            #elsif ($content =~ /\G${b} ($var) [.] $meth ${b}/gcxms) {
            my($va,$me,$pa) = ($1, $2, $3);
            my($vap,$mep,$pap) = ($pre+$-[1],$pre+$-[2],$pre+$-[3]);

            # do we have a reserved word? Could just be a sentence. if(
            if ($me =~ /^$reserved$/) {
                pos($content) = $mep - $pre;
                #print substr($content, $mep - $pre, 4), " $me: pos $mep ", $mep - $pre, "\n";
                next CONTENT;
            }

            #already seen variable and type, so just insert method
            if (defined $var_to_class{$va}) {
                print " variable = $va => class = $var_to_class{$va}\n meth = $me\n param = $pa\n";

                #class already inserted
                $insert_simple->execute($is_snippet, $tid, $du, $var_to_class{$va}, $me, 'method', 0, $mep);

                $extend = $var_to_class{$va} . '.' . $me . '()';
            }
            #if this or super is not defined
            elsif ($va =~ /^(this|super)$/) {
                print " undefined $1: meth = $me\n param = $pa\n";
                $insert_simple->execute($is_snippet, $tid, $du, '!undef!', $me, 'method', 2, $mep);
                $extend = $me . '()';
            }
            #insert variable and method, but variable is not resolved to type
            else {
                print " variable = $va\n meth = $me\n param = $pa\n";
                $insert_simple->execute($is_snippet, $tid, $du, $va, $va, 'variable', 1, $vap);
                $insert_simple->execute($is_snippet, $tid, $du, $va, $me, 'method', 1, $mep);

                $extend = $va . '.' . $me . '()';
            }


            parse($tid, $du, $pa, $d_class, $inside_quote, $is_snippet, $pap);


        }

        #Not interested in this.var unless it's acutally doing something. 
        # must come before general package parsing and var.field, but after var.meth parsing
        elsif ($content =~ /\G${b} (this|super)\.($var)/gcxms) {
            print " don't care about $1\.$2\n\n";
        }

        #Partially qualified: variable.field -- constants are handled below
        #add extends?
        #very limited set of operators following a field from class, var.field is a risky construct, which is also why there isn't any space between var and field
        #   http://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html
        elsif (!defined $inside_quote and 
                $content =~ /\G ${b} (?:(?:this|super) \. )*?  
                                    ($var|$const) [.] ($var) \s* [+*\/-]*[=]/gcxms) {
            my($va,$fi) = ($1, $2);
            my($vap,$fip) = ($pre+$-[1],$pre+$-[2]);

            if (defined $var_to_class{$va}) {
                print " variable = $va => class = $var_to_class{$va}\n field = $fi\n";

                #class already inserted
                $insert_simple->execute($is_snippet, $tid, $du, $var_to_class{$va}, $fi, 'field', 0, $fip);

            }
            elsif ($va =~ /^(this|super)$/) {
                print " undefined $1: field = $fi\n";
                $insert_simple->execute($is_snippet, $tid, $du, '!undef!', $fi, 'field', 5, $fip);
            }
            else {
                print " variable = $va\n field = $fi\n";
                $insert_simple->execute($is_snippet, $tid, $du, $va, $va, 'variable', 1, $vap);
                $insert_simple->execute($is_snippet, $tid, $du, $va, $fi, 'field', 1, $fip);
            }

            print "\n";


        }



        #Partially qualified: Class.method()
        elsif ($content =~ /\G${b} ($class) \s* [.] \s* ($meth) \s* ($RE{balanced}{-parens=>'()'})/gcxms) {
            my($cl,$me,$pa) = ($1, $2, $3);
            my($clp,$mep,$pap) = ($pre+$-[1],$pre+$-[2],$pre+$-[3]);

            # do we have a reserved word? Could just be a sentence. if(
            if ($me =~ /^$reserved$/) {
                pos($content) = $mep - $pre;
                #print substr($content, $mep - $pre, 4), " $me: pos $mep ", $mep - $pre, "\n";
                next CONTENT;
            }



            print " class= $cl\n meth = $me\n param = $pa\n";
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 0, $clp);
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $me, 'method', 0, $mep);
            $extend = $cl . '.' . $me . '()';
            parse($tid, $du, $pa, $d_class, $inside_quote, $is_snippet, $pap);

        }

        #Partially qualified: Class.method (no parenthesis)
        #want to avoid: EofSensorInputStream.java:178 -- exception trace
        #want to avoid README.txt
        elsif ($content =~ /\G${b} ($class) [.] ($meth) ${d}/gcxms) {

            my($cl,$me) = ($1, $2);
            my($clp,$mep) = ($pre+$-[1],$pre+$-[2]);

            if ($me eq 'java') {
                next CONTENT;
            }

            if (meth_two_camel($me) > 0) {
                print " class= $cl\n meth = $me\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 0, $clp);
                $insert_simple->execute($is_snippet, $tid, $du, $cl, $me, 'method', 0, $mep);
                $extend = $cl . '.' . $me . '()';
            }
        }

        #Partially qualified: Class.FIELD 
        elsif ($content =~ /\G${b} ($class) [.] ($const)${d}/gcxms) {
            print " class= $1\n field = $2\n";
            $insert_simple->execute($is_snippet, $tid, $du, $1, $1, 'type', 0, $pre+$-[1]);
            $insert_simple->execute($is_snippet, $tid, $du, $1, $2, 'field', 0, $pre+$-[2]);
            $extend = $1 . '.' . $2;
        }

        #KLUDGE: this|super parsing?
        #Partially qualified: variable.FIELD
        elsif ($content =~ /\G${b} ($var|$const) [.] ($const)${d}/gcxms) {
        #elsif ($content =~ /\G${b} ($var) [.] $meth ${b}/gcxms) {

            my($va,$fe) = ($1,$2);
            my($vap,$fep) = ($pre+$-[1],$pre+$-[2]);

            if (defined $var_to_class{$va}) {
                print " variable = $va => class = $var_to_class{$va}\n field = $fe\n";
                $insert_simple->execute($is_snippet, $tid, $du, $var_to_class{$va}, $fe, 'field', 0, $fep);
                $extend = $var_to_class{$va} . '.' . $fe;
            }
            else {
                print " variable = $va\n field = $fe\n";
                $insert_simple->execute($is_snippet, $tid, $du, $va, $va, 'variable', 1, $vap);
                $insert_simple->execute($is_snippet, $tid, $du, $va, $fe, 'field', 1, $fep);
                $extend = $va . '.' . $fe;
            }

        }

        #TODO: packages: pack.pack...Class var

        #packages: pack.pack...Class ... method or field 
        #use class1 cause we don't want Class.FIELD to be taken as a single class name
        #can also pick up annotation
        elsif ($content =~ /\G${n} (@*($pack [.])+$pack) [.] ($class1) ${d}/gcxms) {
            my($pac,$cl) = ($1,$3);
            my($pacp, $clp) = ($pre+$-[1],$pre+$-[3]);
            print " package = $pac\n class = $cl\n";
            $extend = $cl;

            if ($pac =~ /^@/) {
                print "annotation\n";
                $insert_simple->execute($is_snippet, $tid, $du, $pac, '@'.$cl, 'annotation_package', 10, $pacp);
                $insert_simple->execute($is_snippet, $tid, $du, '@'.$cl, '@'.$cl, 'annotation', 10, $clp);
            }
            else {
                #the package and class
                $insert_simple->execute($is_snippet, $tid, $du, $pac, $cl, 'package', 0, $pacp);
                #the class on its own
                $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 0, $clp);
            }

        }
        #packages: pack.pack....*;
        elsif ($content =~ /\G${n} (@*($pack [.])+$pack) \.\* \s*;/gcxms) {
            my $pac = $1;
            my $pacp = $pre+$-[1];
            print " package = $pac\n";

            if ($pac =~ /^@/) {
                print "annotation\n";
                $insert_simple->execute($is_snippet, $tid, $du, $pac, '.*', 'annotation_package', 10, $pacp);
            }
            else {
                $insert_simple->execute($is_snippet, $tid, $du, $pac, '.*', 'package', 0, $pacp);
            }

            print "\n";

        }
        #packages: must have a later check to ensure that the package actually has Classes
        #   otherwise we'll end up with www.hello.world.com as a package 
        #   important for tutorials that mention package names without Classes frequently
        elsif ($content =~ /\G${n} (@*($pack [.])+$pack) ${b}/gcxms) {
            my $pac = $1;
            my $pacp = $pre+$-[1];
            print " uncertain package (will be checked later) = $pac\n";

            if ($pac =~ /^@/) {
                print "annotation\n";
                $insert_simple->execute($is_snippet, $tid, $du, $pac, '!undef!', 'annotation_package', 10, $pacp);
            }
            else {
                $insert_simple->execute($is_snippet, $tid, $du, $pac, '!undef!', 'package', 9, $pacp);
            }

            print "\n";

        }

        #assignment: catch block
        #e.g., catch (InstantiationException e) {
        elsif ($content =~ /\G${b} catch\s*\(\s* (?:final\s+){0,1} ($class) \s+ ($var) \s*\) \s* \{/gcxms) {
            my($cl, $va) = ($1,$2);
            my($clp, $vap) = ($pre+$-[1],$pre+$-[2]);

            $var_to_class{$va} = $cl;

            print " exception= $cl\n variable = $va\n\n";
            #class
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'exception', 0, $clp);
            #variable
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $va, 'variable', 0, $vap);
        }

        #declaration: constructor
        #e.g., public SomeConstructor()
        elsif (defined $d_class and 
                  $content =~ /\G${b} (?:private|public|protected) \s+ ($class) \s* ($RE{balanced}{-parens=>'()'})/gcxms) {
            
            my($co, $pa) = ($1,$2);
            my($cop, $pap) = ($pre+$-[1],$pre+$-[2]);

            print " class = $d_class\n meth = $co\n param = $pa\n\n";
            $insert_simple->execute($is_snippet, $tid, $du, $d_class, $co, 'constructor', 6, $cop);

           meth_vars($is_snippet, $tid, $du, $pa, $pap); 

        }

        #declaration: method
        #e.g., void methName() throws SomeClass {
        elsif ($content =~ /\G${b} (?:void|$class|$generic|$primative) \s+
                                ($meth) \s* ($RE{balanced}{-parens=>'()'}) 
                                (?:\s+ throws\s+ ((?:$class\s* ,* \s*)+)){0,1} \s* [{;]/gcxms) {

            my($me, $pa) = ($1,$2);
            my($mep, $pap) = ($pre+$-[1],$pre+$-[2]);

            if (defined $d_class) {
                print " class = $d_class\n meth = $me\n param = $pa\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, $d_class, $me, 'method', 6, $mep);
            }
            else {
                print " meth = $me\n param = $pa\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, "!undef!", $me, 'method', 2, $mep);
            }

            if (defined $3) {

                my $th = $3;
                my $thp = $pre+$-[3];

                while ($th =~ /\G ($class)\s* ,* \s*/gcxms) { 
       
                    print " throws class = $1\n";
                    $insert_simple->execute($is_snippet, $tid, $du, $1, $1, 'type', 0, $thp+$-[1]);
                }
            }
    
            #parse the parameters
            meth_vars($is_snippet, $tid, $du, $pa, $pap); 
        }

        #method on it's own 
        #e.g., methName()
        elsif ($content =~ /\G${b} ($meth) ($RE{balanced}{-parens=>'()'})/gcxms) {
            my($me,$pa) = ($1, $2);
            my($mep,$pap) = ($pre+$-[1],$pre+$-[2]);

            if (defined $d_class) {
                print " class = $d_class\n meth = $me\n param = $pa\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, $d_class, $me, 'method', 6, $mep);
                $extend = $me . '()';
            }
            #avoid for example: "we should(but maybe not) use"
            elsif (meth_two_camel($me) > 0) {
                print " meth = $me\n param = $pa\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, "!undef!", $me, 'method', 2, $mep);
                $extend = $me . '()';
            }

            #always need to parse parameters, otherwise we'll miss stuff
            parse($tid, $du, $pa, $d_class, $inside_quote, $is_snippet, $pap);
        }

        #declaration: enums 8.9.1
        #enum SomeEnum {}
        elsif ($content =~ /\G${b} enum \s+ ($class|$const) \s* ($RE{balanced}{-parens=>'{}'})/gcxms) {
            my $cl = $1;
            my $clp = $pre+$-[1];

            print " enum = $cl\n\n";
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'enum', 6, $clp);

        }

        #declaration: annotation 9.6.1
        elsif ($content =~ /\G ${n} \@interface \s+ ($class) \s* ($RE{balanced}{-parens=>'{}'})/gcxms) {
            my $cl = '@'.$1;
            my $clp = $pre+$-[1];

            print " new annotation = $cl\n\n";
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'annotation', 10, $clp);

            #not interested in declaration
            #if (defined $2) {
            #    print " annotation param = $2\n";
            #    parse($tid, $du, $2, $d_class, $inside_quote, $is_snippet, $pre+$-[2]);
            #}


        }
        #declaration: class definition and inheritance (must occur after @interface definition)
        #class SomeClass extends SomeOtherClass {
        elsif ($content =~ /\G${b} (?:class|interface) \s+ ($class) 
                            (?:\s*$RE{balanced}{-parens=>'<>'}){0,1} #KLUDGE: ignore generics for now
                            (?:\s+ extends\s+ ($class|$generic)){0,1} 
                            (?:\s+ implements\s+ ((?:(?:$class|$generic)\s* ,* \s*)+)){0,1}
                            \s* (?=[{])/gcxms) {
    
            my $cl = $1;
            my $clp = $pre+$-[1];

            print " class = $cl\n";
            $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 6, $clp);

            #replace super with the class that is being extended
            if (defined $2) {
                $var_to_class{'super'} = $2;
                print " super class = $2\n";
                $insert_simple->execute($is_snippet, $tid, $du, $2, $2, 'type', 0, $pre+$-[2]);
            }

            if (defined $3) {

                my $im = $3;
                my $imp = $pre+$-[3];

                while ($im =~ /\G ($class|$generic)\s* ,* \s*/gcxms) { 
       
                    print " implements class = $1\n";
                    $insert_simple->execute($is_snippet, $tid, $du, $1, $1, 'type', 0, $imp+$-[1]);
                }
            }

            #new class
            if($content =~ /\G\s* ($RE{balanced}{-parens=>'{}'})/gcxms) {
                $var_to_class{'this'} = $cl;
                parse($tid, $du, $1, $cl, $inside_quote, $is_snippet, $pre+$-[1]);
            }


            print "\n";

        }

        #compound word: class in camel case with at least two words
        elsif ($content =~ /\G${b} ($class) \b/gcxms) {
            my $cl = $1;
            my $clp = $pre+$-[1];

            if (class_two_camel($cl) > 0 and length($cl) <= $MAX_CLASS_LEN) {
                if ($cl =~ /^$const$/xms) {
                    print " field = $cl\n\n";
                    $insert_simple->execute($is_snippet, $tid, $du, '!undef!', $cl, 'field', 5, $clp);
                }
                else {
                    print " class = $cl\n\n";
                    $insert_simple->execute($is_snippet, $tid, $du, '!undef!', $cl, 'type', 3, $clp);
                }
            }
        }

        #ignore non-matching char
        elsif ($content =~ m/\G( . )/xgc) {}; # {print "ILLEGAL CHAR: $1\n"};

        #on vars, classes, constructors, there may be a chain of methods
        if (defined $extend) {

             while ($content =~ /\G [.] \s* ($meth) ($RE{balanced}{-parens=>'()'}) \s*/gcxms) {
                print " extend = $extend\n meth = $1\n param = $2\n";
                $insert_simple->execute($is_snippet, $tid, $du, $extend, $1, 'method', 4, $pre+$-[1]);
                $extend .= '.' . $1 . '()';

                parse($tid, $du, $2, $d_class, $inside_quote, $is_snippet, $pre+$-[2]);
            }

            #KLUDGE: could have field.meth ??
            if ($content =~ /\G \s* [.] ($const) ${d}/gcxms) {
                print " extend = $extend\n field = $1\n";
                $insert_simple->execute($is_snippet, $tid, $du, $extend, $1, 'field', 4, $pre+$-[1]);
            }

            print "\n";
        }

    }
}

sub parse_sec($$$) {
    my($tid, $du, $content) = @_;
    my $is_snippet = 0;

    #the order of the regexp is important, be as specific as possible and 
    # put more general ones later on
    #Not interested in code elements that we found in the first pass
    while (not $content =~ m/\G\z/gc) {

        #are we inside a code snippet?
        #must contain at least one ; otherwise it might just be a code element set out from free-from
        if ($content =~ m|\G $START_CODE|gcxms) { 

            my $tmp_pos = pos($content);

            if ($content =~ m|\G (.*? ; .*?) $END_CODE|gcxms) {
                $is_snippet = 1;
            }

            pos($content) = $tmp_pos; 

        }
        elsif ($content =~ m|\G $END_CODE|gcxms) {
            $is_snippet = 0;
        }


        #don't want to get tricked by if( for example
        if ($content =~ /\G${b} ($reserved \s* [(] )/gcxms) {
            #print "$1 \n\n";
        }

        #discard System methods
        elsif ($content =~ /\G${b} (System([.] $meth)+) ($RE{balanced}{-parens=>'()'})*/gcxms) {
            #print "$1 \n";

       }

       #not interested in method declarations
       elsif ($content =~ /\G${b} ($class|$generic|$primative) \s+
                                ($meth) \s* ($RE{balanced}{-parens=>'()'})/gcxms) {

       }

        #not interested in stacktrace  
        #(BufferedOutputStream.java:65) 
        elsif ($content =~ /\G${b} $class [.] java [:] \d+/gcxms or
                $content =~ /\G${b} \(Native\s Method\)/gcxms) {

        }

        #not interested in annotations will have already processed (), but want unqualified 
        elsif ($content =~ /\G ${n} (\@$class) \s* ($RE{balanced}{-parens=>'()'})* \b/gcxms) {
        }

        #not interested in annotation definition
        elsif ($content =~ /\G ${n} \@interface \s+ $class \s* $RE{balanced}{-parens=>'{}'} /gcxms) {
        }

        #not interested in brackets associated with enum declarations
        elsif ($content =~ /\G${b} enum \s+ ($class|$const) \s* ($RE{balanced}{-parens=>'{}'})/gcxms) {
        }

        #Class.method (no parenthesis)
        elsif ($content =~ /\G\b ($class) [.] ($meth) \b/gcxms) {
            my($cl,$me) = ($1, $2);
            my($clp,$mep) = ($-[1],$-[2]); 

            #Class and method were not found in first pass
            if (!defined $ce_pos{$clp} and !defined $ce_pos{$mep} and 
                    #And it's not two camel 
                    meth_two_camel($me) == 0 and 
                    #And both the class and method are part of our 
                    #collection wide dictionary of valid code elements 
                    defined $ce{$cl} and defined $ce{$me}) {
                
                print " class= $cl\n meth = $me\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, $cl, $cl, 'type', 7, $clp);
                $insert_simple->execute($is_snippet, $tid, $du, $cl, $me, 'method', 7, $mep);
            }
        }

        #TODO: not interested in the innerparts of a generic class?

        #Use test of one camel instead of writing new regexp,
        # otherwise in Author-Book, Book will be picked up on second pass!
        #class one camel
        elsif ($content =~ /\G\b ($class) \b/gcxms) {
            my $cl = $1;
            my $clp = $-[1];

            if (!defined $ce_pos{$clp} and defined $ce{$cl} and 
                length($cl) <= $MAX_CLASS_LEN and class_two_camel($cl) == 0) {

                print " class = $cl\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, '!undef!', $cl, 'type', 7, $clp);
            }
        }
        #constant one camel
        elsif ($content =~ /\G\b ($const) \b/gcxms) {
            my $co = $1;
            my $cop = $-[1];

            if (!defined $ce_pos{$cop} and defined $ce{$co} and 
                length($co) <= $MAX_CLASS_LEN and class_two_camel($co) == 0) {
                print " field = $co\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, '!undef!', $co, 'field', 7, $cop);
            }
        }

        #were afraid of, but should be able to deal with: "we should(but maybe not) use"
        #weren't sure of .meth()
        elsif ($content =~ /\G\b ($meth)\s* ($RE{balanced}{-parens=>'()'}) /gcxms) {

            my $me = $1;
            my $mep = $-[1];

            if (!defined $ce_pos{$mep} and defined $ce{$me} and length($me) > 1) {
                
                print " meth = $me\n\n";
                $insert_simple->execute($is_snippet, $tid, $du, '!undef!', $me, 'method', 7, $mep);
            }

        }

        #method because we didn't trust two camel method by themselves
        #might also be a field, so let's make the kind = !undef!
        #TODO include variables?
        elsif ($content =~ /\G\b ($meth) \b/gcxms) {

            my $me = $1;
            my $mep = $-[1];

            if (!defined $ce_pos{$mep} and defined $ce{$me} and length($me) > 1) {
                if (meth_two_camel($mep) > 0) {
                    print " meth = $me\n\n";
                    $insert_simple->execute($is_snippet, $tid, $du, '!undef!', $me, '!undef!', 7, $mep);
                }
                #useless words like open and query, cause more damage than good
                else {
                    print " (no insert) probably bad meth = $me\n\n";
                    #$insert_simple->execute($is_snippet, $tid, $du, '!undef!', $me, 'method', 11, $mep);
                }
            }

        }

        

        #get rid of illegal char
        elsif ($content =~ m/\G( . )/xgc) {}; # {print "ILLEGAL CHAR: $1\n"};

    }
}

#sub strip_html($) {
#    my ($content) = @_;
#
#    #end of line is uninteresting and would make parsing very complex
#    $content =~ s/[\n\r]/ /g;
#
#    #uggh, annoying >< nonsense!
#    $content =~ s/\&gt;/>/g;
#    $content =~ s/\&lt;/</g;
#    #kludge: eliminate arrays -- just want type
#    $content =~ s/\[\d*\]//g;
#    # sharp # is like a dot
#    $content =~ s/\s#/ /g;
#    $content =~ s/#/./g;
#    # :: is like a dot
#    $content =~ s/::/./g;
#
#    print "$content\n\n";
#
#    return $content;
#
#}

#use HTML::TreeBuilder;
#use HTML::FormatText;
#
#sub strip_html($) {
#
#    my ($content) = @_;
#
#    my$tree = HTML::TreeBuilder->new->parse_content($content);
#    my $formatter = HTML::FormatText->new(leftmargin => 0, rightmargin => 50);
#    $content = $formatter->format($tree);
#
#    #end of line is uninteresting and would make parsing very complex
#    $content =~ s/[\n\r]/ /g;
#
#    #uggh, annoying >< nonsense!
#    $content =~ s/\&gt;/>/g;
#    $content =~ s/\&lt;/</g;
#    #kludge: eliminate arrays -- just want type
#    $content =~ s/\[\d*\]//g;
#    # sharp # is like a dot
#    $content =~ s/\s#/ /g;
#    $content =~ s/#/./g;
#    # :: is like a dot
#    $content =~ s/::/./g;
#
#    print "$content\n\n";
#
#    return $content;
#}



#tags from http://www.w3schools.com/tags/default.asp
my $html = '\!\-\-|\!DOCTYPE|a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|col|colgroup|dd|del|dfn|dir|div|dl|dt|em|fieldset|font|form|frame|frameset|head|h[1-6]|hr|html|i|iframe|img|input|ins|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|pre|code';


sub strip_html($) {

    my ($content) = @_;

    #print "$content\n\n";

    #end of line is uninteresting and would make parsing very complex
    $content =~ s/[\n\r]/ /g;

    #uggh, annoying >< nonsense!
    $content =~ s/\&gt;/>/g;
    $content =~ s/\&lt;/</g;

    #want to keep code snips
    $content =~ s/<pre><code>/$START_CODE/gxms;
    $content =~ s|</code></pre>|$END_CODE|gxms;

    #will eat int etc as generic
    $content =~ s/<\/* ($html) .*?>/ /gxms;

    #kludge: eliminate arrays -- just want type
    $content =~ s/\[\d*\]//g;
    # sharp # is like a dot
    $content =~ s/\s#/ /g;
    $content =~ s/#/./g;
    # :: is like a dot
    $content =~ s/::/./g;

    #print $content, "\n\n";

    return $content;
}

sub process ($$$) {
    
    my($tid, $du, $content) = @_;
    
    %var_to_class = (); #hash map of variable definitions to type

    if(!defined $pass or $pass eq 'first') {

        #no declared class, not in quotes, not in snippet, and at begining
        parse($tid, $du, $content, undef, undef, 0, 0); 

    }
    elsif ($pass eq 'second') {
        
        #reset hash position of ce's (for second pass)
        %ce_pos = ();

        $get_pos->execute($du) or die $dbh_ref->errstr;

        while ( my($pos, $simple) = $get_pos->fetchrow_array) {
            $ce_pos{$pos} = $simple;
        }

        parse_sec($tid, $du, $content);
        #link
        #resolve($tid, $du); 
        #remove unmatched ie still with 7s and no reason 

    }
    else {
        print STDERR "$pass is invalid option\n";
    }

}

sub code_snips_to_htlm($) {

    my ($content) = @_;
    $content =~ s/$START_CODE/<code>/g;
    $content =~ s/$END_CODE/<\/code>/g;
    return $content;

}

#
# Step through all the directories
#
sub process_dir {

	my ($path, $config_ref, $db_check_repo_ref) = @_;

	chdir $path or die "Cannot processes $path";
	my $cwd = getcwd;
	print "\n\n", $cwd, "\n";

	if ($cwd =~ m|/sub\-\w+\.html$|xms) {
		if ($cwd =~ /$config_ref->{path_ignore}(.*)$/xms) {
			my $short_path = $1;
            print "tid = $short_path\n";

# KLUDGE: messes up second pass
#			$db_check_repo_ref->execute($short_path) or warn "Problem checking if thread has already been processed\n";
#			if ($db_check_repo_ref->rows > 0) {
#            #check if thread already exists
#                print "Skipping ... we've already done this thread: $short_path\n";
#			}
#			else {
#
                foreach my $next_path (<*>) {
                    print "du = $next_path\n";

                    my $content;
                    my $file = IO::File->new($next_path, 'r') or warn "$! $next_path\n";
                    while(<$file>) {
                        $content .= $_;
                    }
                    $file->close;

                    #process
                    $content = strip_html($content);
                    #Kludge: make du globally unique
                    process($short_path, $short_path . '/' . $next_path, $content);

                }
#            }
        }

	}
	else {
		foreach my $next_path (<*>) {
			if (-d $next_path) {
				process_dir($next_path, $config_ref, $db_check_repo_ref);
			}
		}
	}
	chdir '..' or die "Cannot backout of $path";
}

sub rm_squiggly{
		
	my ($start) = $_[1];
	for (my $i = $start + 1; $i < length($_[0]); $i++){
		if (substr($_[0], $i, 1) eq '{'){
			rm_round($_[0], $i);
		}
		if (substr($_[0], $i, 1) eq '}'){
			substr($_[0], $start, $i - $start + 1) = "";
			last;
		}	
	}
}

sub rm_round{
		
	my ($start) = $_[1];
	for (my $i = $start + 1; $i < length($_[0]); $i++){
		if (substr($_[0], $i, 1) eq '('){
			rm_round($_[0], $i);
		}
		if (substr($_[0], $i, 1) eq ')'){
			substr($_[0], $start, $i - $start + 1) = "";
			last;
		}	
	}
}

sub rm_square{
		
	my ($start) = $_[1];
	for (my $i = $start + 1; $i < length($_[0]); $i++){
		if (substr($_[0], $i, 1) eq '['){
			rm_round($_[0], $i);
		}
		if (substr($_[0], $i, 1) eq ']'){
			substr($_[0], $start, $i - $start + 1) = "";
			last;
		}	
	}
}

#removes lines of code, dates, time etc.
sub clean_body{

	my ($body) = $_[0];
	#remove squiggly brackets
	for (my $i = 0; $i < length($body); $i++){
		if (substr($body, $i, 1) eq '{'){
			rm_squiggly($body,$i);
		}
	}

	#remove round brackets
	for (my $i = 0; $i < length($body); $i++){
		if (substr($body, $i, 1) eq '('){
			rm_round($body,$i);
		}
	}

	#remove square brackts
	for (my $i = 0; $i < length($body); $i++){
		if (substr($body, $i, 1) eq '['){
			rm_square($body,$i);
		}
	}

	#remove point concatinated
	$body =~ s/( \S+? (\.\S+){2,}?  )//gxe;
		
	#remove / concatinated
	$body =~ s/( \S+? (\/\S+){2,}?  )//gxe;
	
	#remove _ concatinated
	$body =~ s/( \S+? (_\S+){2,}?  )//gxe;
	
	#remove attachments
	$body =~ s/Attachment: HADOOP-\S+?\s//g;
	
	#remove web address
	$body =~ s/(http|https):\/\/\S+?\s//g;
	
	#Content type: something
	$body =~ s/Content-Type: \S+?\s//g;
	
	#charset="something"
	$body =~ s/charset="\S+?"\s//g;
	
	#Content-Transfer-Encoding: something
	$body =~ s/Content-Transfer-Encoding: \S+?\s//g;
	
	#lines starting with two or more dashes --....
	$body =~ s/(^|\s)--\S+?\s//g;	
	
	#remove filetypes, .jar .java etc
	$body =~ s/(\.jar|\.java|\.xml|)//g;

	#remove numbers and punctuation
	$body =~ s/[\d\$#@~!&*;,?^'=:<>\."\/\(\)\{\}\[\]]+//g;

	$body =~ tr|-| |;

	#remove <stuff..>
	$body =~ s/<[^>]*\>//g;


	

	return $body;
							
}

#nlp techniques
sub remove_stop_words{

	my ($body) = $_[0];
	$body = lc($body);
	my $stopwords = getStopWords('en');
	my @words = split(' ', $body);
	my $scalartext = join ' ', grep {!$stopwords -> {$_} } @words;
	#$scalartext =~ s/\h+/ /g;
	return $scalartext;
}

#wordsplit
sub split_words{
	
	my ($body) = $_[0];
	my @arrayAll;
	my @scalarArray = split (' ', $body);
	foreach $word (@scalarArray){
		my @array = wordsplit($word);
		push(@arrayAll, @array);
	}
	
	my $splittext = join ' ', @arrayAll;
	return $splittext;
}

#remove java and common keywords
sub remove_java{
	
	my ($body) = $_[0];
	my @body_list = split(' ', $body);
	my $filename = "files/common-words.txt";
	open($file, $filename) or die ("could not open file");

	my @commonWords;
	foreach my $line (<$file>){
		push(@commonWords, $line);
	}

	my %stop = map { lc $_ => 1} @commonWords;
	my (@ok, %seen);
	foreach (@body_list){
		push @ok, $_ unless $stop{lc $_} or $seen{lc $_}++;	
	}
	$body = join ' ', @ok;
	return $body;
}

#generate ngrams
sub getnGram{
	my ($body) = $_[0];
	my $nGramSize = 5;
	my $nGramOrderCriteria = 'frequency';
	my $onlyFirst = 5;
	my $normalizeFrequency = 1;
	my $onlyMostFrequentng = 1;
	my $nGram = Text::Ngrams -> new ( windowsize => $nGramSize, type => word);
	$nGram -> process_text($body);
	my $n_gram = $nGram -> to_string(orderby => $nGramOrderCriteria, onlyfirst => $onlyFirst, normalize => $normalizeFrequency, spartan => $onlyMostFrequent);
	return $n_gram;
}

#testing purposes -> feed a file: e.g., dealwiththis.txt
if($config{doc_type} eq 'test') {
    my $content;
    my $title;
    while (<>) {
        $content .= $_;
    }

    if (defined $content) {
        my $tid = 'test_thread';
        my $du = 'test_du';

        print "\n\nprocessing du = $du\n";
        process($tid, $du, strip_html($content));
    }
}

elsif($config{processing} eq 'summary' and $config{doc_type} eq 'email') {
	my $get_pos_len = $dbh_ref->prepare(qq{select du, pqn, simple, kind, pos, length(simple) as len from clt where trust = 0 and kind <> 'variable' and du = '1035654119.30.1388136223004.JavaMail.hudson\@aegis' order by du, pos});
	#my $get_pos_len = $dbh_ref->prepare(qq{select du, pqn, simple, kind, pos, length(simple) as len from clt where simple = 'TestWritable' order by du, pos limit 5});
	my $get_du = $dbh_ref->prepare(q[select thread_id, msg_id, subject, body from email where msg_id = ?]);

	$get_pos_len->execute or die;
	my $sc;
   
	my $body;
	my $clean_body;
	my $cleaner_body;
	my $split_text;
	my $more_body;
	my $ngram;


	while(my ($du, $pqn, $simple, $kind, $pos, $len) = $get_pos_len->fetchrow_array){
				
		$get_du->execute($du) or die "Can't get body from db ", $dbh_ref->errstr;
		my($thread_id, $du, $subject, $body) = $get_du->fetchrow_array;
		if (defined $subject){
			$body .= $subject . ' ';
		}
		$sc = strip_html($body);
		
		#$split_text = split_words($sc);
		
		$clean_body = clean_body($sc);

		$cleaner_body = remove_stop_words($clean_body);
	
		$more_body = remove_java($cleaner_body);
	
		my $dir = dir("/home/da_bourq/Desktop/test");
		my $filename = $dir -> file("$simple".'_'."$du".".txt");
		
		open (my $fh, '>', $filename);
		print $fh $more_body;
		close $fh;


		#$ngram = getnGram($more_body);	

		print "ORIGINAL:\n$body\n\nFIRSTPASS:\n$clean_body\n\nSECONDPASS\n$cleaner_body\n\nTHIRDPASS\n$more_body\n\nNGRAM:\n\n";
	
		

		#if ($pqn !~ /.*\..*/){
		#	print "pqn: ".$pqn."\n"."simple: ".$simple."\n"."we get: ".substr($sc, $pos, $len)."\n\n";
			
		#}
	}


}


#
#From emails 
elsif($config{doc_type} eq 'email') {


    my $get_du = $dbh_ref->prepare(q{select thread_id, msg_id, subject, body from email});
    $get_du->execute or die "Can't get body from db ", $dbh_ref->errstr;

   
    while ( my($tid, $du, $subject, $content) = $get_du ->fetchrow_array) {

	    $content .= $subject . ' ';

            print "\n\nprocessing: tid = $tid email = $du\n";
            process($tid, $du, strip_html($content));
        }

}


#for regenerating the text to dump into nlp pipeline
elsif($config{processing} eq 'nlp' and $config{doc_type} eq 'stackoverflow') {

    my $get_du = $dbh_ref->prepare(qq[
                  select parentid, id, title, body, msg_date from                                                                                                                                                              
                  (select id as parentid, id, title, body, creationdate as msg_date from posts where id in (select id from posts where tags ~ E'lucene') --the parents                                                                
                  union select parentid, id, title, body, creationdate as msg_date from posts where parentid in (select id from posts where tags ~ E'lucene')) as r --the children                                                    
                  order by parentid, msg_date asc
                  ]);

    my $get_pos_len = $dbh_ref->prepare(qq{select pqn, simple, kind, pos, length(simple) as len from clt where trust = 0 and du = ?  order by pos});

    $get_du->execute or die "Can't get doc units from db ", $dbh_ref->errstr;


    my %map_kind = (
        type => '<FONT COLOR="RED">',
        method => '<FONT COLOR="BLUE">',
        variable => '<FONT COLOR="GREEN">',
        field => '<FONT COLOR="ORANGE">',
        package => '<FONT COLOR="yellow">',
        annotation => '<FONT COLOR="purple">',
        enum => '<FONT COLOR="grey">',
        annotation_package => '<FONT COLOR="purple">',
    );

    my $end_kind = '</FONT>';

    #Stackoverflow
    while ( my($tid, $du, $title, $content) = $get_du ->fetchrow_array) {

        #print "Link: http://stackoverflow.com/questions/$du\n";
        #print $title . $content;

        if(defined $title) {
            $content = $title . ' ' . $content;
        } 

        #print "\n\nprocessing du = $du\n";
        my $sc = strip_html($content);
        #print STDERR "$sc\n\n";
        #process($tid, $du, strip_html($content));


        $get_pos_len->execute($du) or die "Can't get clts from db ", $dbh_ref->errstr;

        print "<br><a href=\"http://stackoverflow.com/questions/$du\">Post: $du</a>\n<br>";
        my $old_end = 0;
        while ( my($pqn, $simple, $kind, $pos, $len) = $get_pos_len->fetchrow_array) {
            #test - print " $old_end, $pos, $len --", substr($sc, $old_end, $pos-$old_end), "\n";
            my $current = substr($sc, $old_end, $pos-$old_end);
            print code_snips_to_htlm($current);
            $old_end = $pos+$len;
            #test - print " $old_end, $pos -- prxh_$kind\{$pqn\.$simple\} \n";
            print " $map_kind{$kind}$pqn\.$simple$end_kind ";
        }

        print code_snips_to_htlm(substr($sc, $old_end, length($sc)));
        print "<br><a href=\"http://stackoverflow.com/questions/$du\">Post: $du</a><br>\n";

    }
    $get_du->finish;
}
#
#From plaintext documents
elsif($config{doc_type} eq 'plain') {

    my $files_obj = File::Find::Rule->file()
                                 ->start($config{dir});

    while (my $file = $files_obj->match() ) {

        #print "$file\n";
        if ($file =~ m|\Q$config{ignore_path}\E/*(.*?)([^/]+)$|) {
            my $tid = $1;
            my $du = $2;

            print "\n\nprocessing: dir or tid = $tid file or du = $du\n";
            my $content = read_file($file);
            process($tid, $du, strip_html($content));
        }


        last;

    }

}
#
#For latifa 
elsif($config{doc_type} eq 'latifa') {

    my $q = qq[select sequence, sec_title, sec_content from $config{table_name}];

    my $get_du = $dbh_ref->prepare($q);

    $get_du->execute or die "Can't get doc units from db ", $dbh_ref->errstr;

    #Stackoverflow
    while ( my($du, $title, $content) = $get_du ->fetchrow_array) {
        my $tid = $du;

        if(defined $title) {
            $content = $title . ' ' . $content;
        }


        print "\n\nprocessing du = $du\n";
        process($tid, $du, strip_html($content));

    }
    $get_du->finish;
}

#
#For stackoverflow
elsif($config{doc_type} eq 'stackoverflow') {

    #my $get_du = $dbh_ref->prepare(qq[select parentid, p.id, title, body, p.creationdate as msg_date, owneruserid as nickname, displayname as name, emailhash as email from posts p, users u where owneruserid = u.id and parentid in (select id from posts where tags ~ E\'$config{tags}\') order by parentid, p.creationdate asc]);

    #instead of old query above which modifies stackoverflow tables, we union the parents and the children (parents don't have a parentid) 
    my $q = qq[
                  select parentid, id, title, body, msg_date from                                                                                                                                                              
                  (select id as parentid, id, title, body, creationdate as msg_date from posts 
                    where id in (select id from posts where tags ~ E\'$config{tags}\') --the parents (or questions)                                                        
                  union select parentid, id, title, body, creationdate as msg_date from posts 
                    where parentid in (select id from posts where tags ~ E\'$config{tags}\') --the children (answers)                                                   
                    ) as r 
                  order by parentid, msg_date asc
                  ];

#    #lucene is implemented in all kinds of languages, so need complex regexp
#    my $q = q[
#                  select parentid, id, title, body, msg_date from                                                                                                                                                              
#                  (select id as parentid, id, title, body, creationdate as msg_date from posts 
#                    where id in (select id from posts where tags ~ E'lucene' and (tags ~ E'java' or tags !~ E'net|c#|php|nhibernate|zend|clucene|ruby|c\\\\+\\\\+|pylucene|python|rails')) 
#                  union select parentid, id, title, body, creationdate as msg_date from posts 
#                    where parentid in (select id from posts where tags ~ E'lucene' and (tags ~ E'java' or tags !~ E'net|c#|php|nhibernate|zend|clucene|ruby|c\\\\+\\\\+|pylucene|python|rails')) 
#                    ) as r 
#                  order by parentid, msg_date asc
#                  ];

    my $get_du = $dbh_ref->prepare($q);



    $get_du->execute or die "Can't get doc units from db ", $dbh_ref->errstr;

    #Stackoverflow
    while ( my($tid, $du, $title, $content) = $get_du ->fetchrow_array) {

        if(defined $title) {
            $content = $title . ' ' . $content;
        }


        print "\n\nprocessing du = $du\n";
        process($tid, $du, strip_html($content));

    }
    $get_du->finish;
}
#
#For recodoc -- legacy 
elsif($config{doc_type} eq 'recodoc') {

    my $get_du = $dbh_ref->prepare(q{select t.url, m.url, m.title, m.text_content from channel_message m, channel_supportthread t where m.sthread_id = t.id and t.channel_id = 2});
    #and m.url = '199145'}); #for stacktraces
    #m.url = '1150615'}); #test for generics # and m.url = '1116614'});
    $get_du->execute or die "Can't get doc units from db ", $dbh_ref->errstr;

    #Stack overflow
    while ( my($tid, $du, $title, $content) = $get_du ->fetchrow_array) {

        if(defined $title) {
            $content = $title . ' ' . $content;
        }
            #test - print " $old_end, $pos -- prxh_$kind\{$pqn\.$simple\} \n";


        print "\n\nprocessing du = $du\n";
        process($tid, $du, strip_html($content));

    }
    $get_du->finish;
}
#tutorial
elsif($config{doc_type} eq 'tutorial') {

    my $db_check_repo_ref = $dbh_ref->prepare(q{select tid from clt where tid = ? group by tid});
    process_dir($config{path}, \%config, $db_check_repo_ref);
    $db_check_repo_ref->finish;
}
else {
    print STDERR "Invalid doc_type ", $config{doc_type};
}

#in effect we are doing one giant insert, so we'll just do one commit at the end
$dbh_ref->commit;

$insert_simple->finish;
$get_pos->finish;
$dbh_ref->disconnect;

__END__

See README.txt
