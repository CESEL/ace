=ACE - Automated Code Element Extractor=

ACE resolves code-like terms to their corresponding code element kind

There are two stages:
# Find code elements that are unambiguous 
# Based on index of unambiguous code elements find those that are ambiguous and try to resolve them to an unambiguous type

More details in Rigby and Robillard ICSE 2013.

==NOTES==

* ACE is designed for parsing code snippets and freeform text not entire source code files
** Scope rules are expanded to include documentation untis, etc
* ACE includes elements from stacktraces

== Special Cases ==
* Ignore: System.* (e.g., System.out.println)
* Ignore: Default annotation (e.g., @Override)

==Input and Output==
* ACE takes plain ascii text files
* ACE outputs creates a number of tables, with table clt storing the code elements in each document

==Required Perl Libraries==

*use DBI; #postgres
*use Cwd;
*use Regexp::Common; 
*use IO::File;
*use Config::General;

*To install, for example,
** apt-get install libConfig-General-perl

==Run==

* See the example config file, you'll need to setup the db etc
** src/example.conf

* resolve.sh will run all the appropriate perl and sql scripts 
** ./resolve.sh <db_name> <config_file>

* There are a few checks you can perform afterwards in src/checks.sql

==The Output==
*Just dump the clt table (Code Like Term) to a file
** select tid, du, pqn, simple, kind from clt where trust = 0 and kind <> 'variable';

* tid = The thread id or question id
* du = the document unit or post id
* pqn = the partially qualified name (we don't resolve all the way back to packages)
* kind = the type, method, field, package, annotation, etc
* simple = the name of the code element (variables are not code elements and are only used as intermediaries)
* trust = only want trust = 0, anything higher has been rejected

==What do the trust values mean?==

If you just include code elements with trust 0, you'll be fine, if you want to know where things came from then you can look at the trust_original values:

0 -> naturally good: qualified or defined or a new Constructor()
1-> variable and member, but variable is unresolved
2-> method undefined
3-> type undefined
4-> chain of methods, can have undefined type 
5-> field undefined
6-> declaration of constructor, method, class
7-> second pass from dictionary
8-> stacktrace
9-> ambigious package name
10-> annotation or annotation_package
11-> non-compound second round (may not be processed)

=== CE Context===

* if you're interested in finding out which context something came from see context.sql

== MOTIVATION ==
See results_motivation.sql  

== Manual Validation ==

Here are some scripts to do manual validation:
* Special cases -> results_compound_types.sql
* See benchmark.sql -> dumps current bench_good.csv and creates a new bench.csv for analysis, also fills out the benchmark table
* results_ace_tables.sql -> ace result tables including precision and recall

== Salience ==

results_salience.sql
* need to run tf_idf.sql first
* in benchmark how many ces are salient?
* extract attributes including tfidf and dump to arff 
* add the arff header -> arff_header.arff

== Further NLP parsing ==

*update the conf file adding the following: processing=nlp
**if processing is not present in the config files, normal code element extraction will occur
** ./resolve.pl <config file> first 
*TODO: ambigious terms that are resolved in another part of the doc will not be highlighted earler. For example a class called Intent may not get it's position reported.



