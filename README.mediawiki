=ACE - Automated Code Element Extractor=

ACE extracts code elements (classes, methods, fields, etc) found in freeform ASCII text documents. It does not require any apriori knowledge of the code elements, but does require a large corpus of documents. The island parser is java based.

There are two stages:
# Find code elements that are unambiguous and build a index of valid ce in the document corpus
# Find ambiguous code elemetns, and use the index to resolve them to their declaring type

More details in Rigby and Robillard ICSE 2013.

==Required Libraries==

* sudo apt-get install postgresql libConfig-General-perl libIO-File-perl libRegexp-Common-perl libdbd-pg-perl

==Run==

* As Input ACE can take any plaintext document, it can also process stackoverflow db in postgres format

* See the example config file
** src/example.conf

* resolve.sh will run all the appropriate perl and sql scripts 
** <pre> ./resolve.sh db_name config_file 2> project_name/project.error | tee project_name/project.out </pre>

* certain two camel words are are not valid classes and are project specific. (e.g., HttpClient is both a class and a project)
** Add these terms to src/project_specific/<project_name>.sql 

* if you're going to run more than one project/tag through ACE in the same db,
** you'll need to modify: src/rename_tables.sql 

==The Output==
*Just dump the clt table (Code Like Term) to a file
** select tid, du, pqn, simple, kind from clt where trust = 0 and kind <> 'variable';

* tid = The thread id or question id
* du = the document unit or post id
* pqn = the partially qualified name (we don't resolve all the way back to packages)
* kind = the type, method, field, package, annotation, etc
* simple = the name of the code element (variables are not code elements and are only used as intermediaries)
* trust = only want trust = 0, anything higher has been rejected


==NOTES==

* ACE is designed for parsing code snippets and freeform text not entire source code files
** Scope rules are expanded to include documentation untis, etc
* ACE includes elements from stacktraces

== Special Cases ==
* Ignore: System.* (e.g., System.out.println)
* Ignore: Default annotation (e.g., @Override)

==What do the trust values mean?==

If you just include code elements with trust 0, you'll be fine, if you want to know where things came from then you can look at the trust_original values:

<pre>
0 -> naturally good: qualified or defined or a new Constructor()
1-> variable and member, but variable is unresolved
2-> method undefined
3-> type undefined
4-> chain of methods, can have undefined type 
5-> field undefined
6-> declaration of constructor, method, class
7-> second pass from dictionary
8-> stacktrace
9-> ambigious package name
10-> annotation or annotation_package
11-> non-compound second round (may not be processed)
12-> project specific badness
</pre>

=== CE Context===

* if you're interested in finding out which context a CE came from see context.sql

== MOTIVATION ==
See results_motivation.sql  

== Manual Validation ==

Here are some scripts to do manual validation:
* There are a few checks you can perform afterwards in src/post_analysis/checks.sql
* Special cases -> results_compound_types.sql
* See benchmark/benchmark.sql -> dumps current bench_good.csv and creates a new bench.csv for analysis, also fills out the benchmark table
* results_ace_tables.sql -> ace result tables including precision and recall

== Salience ==

results_salience.sql
* need to run tf_idf.sql first
* in benchmark how many ces are salient?
* extract attributes including tfidf and dump to arff 
* add the arff header -> arff_header.arff

== Further NLP parsing ==

*update the conf file adding the following: processing=nlp
**if processing is not present in the config files, normal code element extraction will occur
** ./resolve.pl <config file> first 
*TODO: ambigious terms that are resolved in another part of the doc will not be highlighted earler.
